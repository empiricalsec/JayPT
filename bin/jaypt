#!/usr/bin/env ruby

require_relative "../lib/jaypt"
require "csv"
require "concurrent-ruby"

$stderr = File.open("errors.log", "w")

models = [
  "google/gemini-2.5-pro-preview",
  "x-ai/grok-3-beta",
  "anthropic/claude-3.7-sonnet",
  "openai/gpt-4o-mini"
]

POOL_SIZE = 8

if ARGV.first =~ /\.csv$/
  raise "Second argument must be an output CSV file" if ARGV[1] !~ /\.csv$/

  puts "Models: #{models.join(', ')}"
  puts "Writing to #{ARGV[1]}"
  puts "Pool size: #{POOL_SIZE}"

  pool = Concurrent::FixedThreadPool.new(POOL_SIZE)
  futures = []

  CSV.open(ARGV[1], "w") do |csv|
    csv << %w[model cve score analysis inference_time input_tokens output_tokens]

    CSV.foreach(ARGV.first, headers: true) do |row|
      csv << [row["Model"], row["CVE ID"], row["Score"], "", 0, 0, 0] if row["Model"] && row["Score"]

      models.each do |model|
        futures << Concurrent::Promises.future_on(pool) do
          agent = JayPT::Agent.new(model:)
          results = agent.score_cve(row["CVE ID"])

          csv << [
            model,
            row["CVE ID"],
            results[:score],
            results[:analysis],
            results[:inference_time].round(1),
            results[:input_tokens],
            results[:output_tokens]
          ]

          puts "Analyzed #{row['CVE ID']} (#{model})"
        rescue StandardError => e
          csv << [model, row["CVE ID"], 0, "ERROR: #{e.class} - #{e.message[0..100]}", 0, 0, 0]
          puts "Error analyzing #{row['CVE ID']} (#{model}): #{e.class} - #{e.message}"
        end
      end
    end

    Concurrent::Promises.zip(*futures).value!
  end
else
  puts "Running models against #{ARGV.first}\n\n"

  threads = models.map do |model|
    Thread.new do
      agent = JayPT::Agent.new(model:)
      results = agent.score_cve(ARGV.first)

      puts <<~OUTPUT
        Model: #{model}
        Score: #{results[:score]}
        Analysis: #{results[:analysis]}
        Inference time: #{results[:inference_time].round(1)} seconds
        Input tokens: #{results[:input_tokens]}
        Output tokens: #{results[:output_tokens]}

      OUTPUT
    rescue StandardError => e
      puts <<~OUTPUT
        Model: #{model}
        Error: #{e.class} - #{e.message}

      OUTPUT
    end
  end

  threads.each(&:join)
end
